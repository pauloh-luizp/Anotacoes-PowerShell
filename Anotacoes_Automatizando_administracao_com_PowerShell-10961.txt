2.Começando a usar o PowerShell========================================
=======================================================================
Entendendo a sintaxe dos comandos======================================

Encontrando os comandos================================================


3.CMDLETs para adminstração============================================
=======================================================================
CMDLETs para adminstração do AD========================================

#Criando usuário
~New-ADUser "Henry" -AccountPassword (ConvertTo-SecureString "senha"
  -asplaintext -force) -DisplayName "Henry" -Enable $true

#Gestão de grupo
~New-ADGroup "Win-Support" -GroupScope Global

#Adicionado usuários ao grupo
~Add-ADGroupMember "Win-Support" -Members "user1","user2"

#Adcionando computadores ao AD
~New-ADComputer <nome> -Enable $true

#Adicionando nova unidade organizacional
~New-ADOrganizationalUnit "OU-support"


CMDLETs para administracao de Redes====================================

#Configurando o IP
~New-NetIPAddress -IPAddress 192.168.0.171 -InterfaceAlias "Ethernet"
  -PrefixLength 16 -DefaultGateway 192.168.0.254

#Comandos de DNS
~Get-DnsClient

#Comandos de ServerZone
~Get-DnsServerZone


Outros CMDLETs para adminstracao de servidores=========================

~Get-Command -Module GroupPolicy

#Criando GPO
~New-GPO -Name "Win-Support"

#Exibindo todas as aplicacoes instaladas
~Get-WindowsFeature

#Instalando um recurso do sistema
~Install-WindowsFeature <recurso>

#Comando voltados para o Hyper-V
~Get-Command -Module Hyper-V

4.Trabalhando com o PipeLine do PowerShell=============================
=======================================================================
Seleção, organizacao e medindo os objetos no pipeline==================

#Ordenando
Get-Service | Sort-Object -Property Status,Name -Descending 
  | fw -Groupby Status

#Medindo
Get-Process | Measure-Object

#Selecionando
Get-Process | Sort-Object -Property VM | Select-Object -First 30

#Unicos
 | Select-Object -Unique

#Usando HashTables
Get-Process | Select-Object -Property Name, ID, @{n="Virtual Memory"; 
  e={$PSItem.vm / 1MB}}, @{n="Page Memory"; e={$PSItem.pm /1MB}}

Filtrando objetos enviados do pipeline=================================

-ceq case sensitive equal

Get-Services | Where-Object Status -eq "Running"
Get-Services | Where -FilterScript {$PSItem.Status -eq "Running"}
Get-Services | ? -FilterScript {$_.Status -eq "Running"}


Enumerando objetos vindo do pipeline===================================

Get-ChildItem -Path c:\Exemple -File | ForEach-Object <acao>
Get-ChildItem -Path c:\Exemple -File | % <acao>


Convertendo as saídas do pipeline======================================

 | Out-File -FilePath c:\arq.csv

 | ConvertTo-csv | Out-File -FilePath c:\arq.csv

 | Export-csv c:\arq.csv

 | Export-CliXml c:\arq.xml

 | Out-Printer

 | Out-GridView


5.Entendendo como o Pipeline funciona==================================
=======================================================================
Enviando dados para o pipeline=========================================

Get-Process -name notepad | Stop-Process


Considerações avançadas para o uso do pipeline=========================

#Comandos entre parenteses, executa o que está em parenteses primeiro
  ~Get-ADGroup "Win-Support" | Add-ADGrupMember -Members (Get-ADuser 
    -Filter {city -eq "Curitiba"})

6.Usando PSProviders aos PSDrives======================================
=======================================================================
Usando PSProviders=====================================================

Fornecem as estruturas e serviços que os Drivers precisam

~Get-PSProviders


Usando PSDrives========================================================

~Get-PSDrive

Podemos usar o help para ver o manual de utilização do Driver

~help FileSystem

Trabalhar com PSDrive é uma forma de estruturar de padronizar a estru-
  tura independente do sistema operacional. Abstrair a estrutura logica
  do sistema de arquivos

Criando um Drive:
  ~New-PSDrive -Name <nome> -PSProvider <provider> -Root c:\


7.Buscando informações de sistema usando o WMI e o CIM=================
=======================================================================
Entendendo WMI e CIM===================================================

WMI - Windows Managemnt Instrumentation
  Infraestrutura para dados de gerenciamento e operações em sistemas
  operacionais baseados no Windows e outros produtos Microsoft
  O WMI é construído com base nos padrões WBEM e CIM da 
  Distributed Management Task Force (DMTF). As informações do sistema
  nas camadas de hardware e software são expostas por meio de uma 
  interface padrão por meio do WMI. O resultado líquido disso é a 
  capacidade de visualizar facilmente e, às vezes, modificar as 
  informações do sistema e as definições de configuração.

CIM - Common Interface Model
 O CIM fornece uma definição comum de informações de gerenciamento 
 para sistemas, redes, aplicativos e serviços, e permite extensões de 
 fornecedores. As definições comuns da CIM permitem que os fornecedores
 troquem informações de gerenciamento semanticamente ricas entre 
 sistemas em toda a rede.


Buscando e filtrando dados usando o WMI e o CIM========================

Get-WmiObject -Namespace root\CIMv2 -list

Get-CimClass -Namespace 

Conseguimos usar SQL nas consultas
~Get-CimInstance -Query "SELECT * FROM win32_logicaldisk 
  WHERE DriveType = 3"

Sessões
~New-CimSession -ComputerName <nome>


Fazendo mudanças no sistema via WMI/CIM================================

Desligando o sistema
~Invoke-WmiMethod -Class win32_operatingSystem -Name win32Shutdown
  -ArgumentList 0 -ComputerName <nome>


8.Trabalhando com variáveis, arrays e hash tables======================
=======================================================================
Usando variáveis=======================================================




11.Administrando computadores Remotos==================================
=======================================================================
Usando o controle remoto básico========================================

Ativando o controle remoto
~Enable-PSRemoting

Sessão remota persistentes
~Enter-PSSession -ComputerName <nome>

Sessão remota eferemera
~Invoke-Command -ComputerName <nome> -ScriptBlock {Get-service}
  *permitido no máximo 32 comandos


Usando técnicas avançadas de acesso remoto=============================

Usando parâmetros:
  
$log = "Security"
$quant = 15

Invoke-Command -ComputerName <nome> -ScriptBlock {
  Param ($LogRem, $QuantRem)
  Get-EventLog -LogName $LogRem -Newest $QuantRem | ft -AutoSize
} -ArgumentList $Log, $Quant


Usando PSSessions======================================================

New-PSSession <nome>

Connect-PSSession -Id <id>

Exit-PSSession


